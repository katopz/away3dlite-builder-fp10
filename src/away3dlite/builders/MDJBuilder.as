package away3dlite.builders{	import away3dlite.animators.MovieMesh;	import away3dlite.arcane;	import away3dlite.core.base.Object3D;	import away3dlite.core.utils.Debug;	import away3dlite.loaders.data.AnimationData;	import away3dlite.loaders.data.MaterialData;	import away3dlite.materials.BitmapMaterial;		import com.adobe.serialization.json.JSON;		import flash.utils.Dictionary;

	use namespace arcane;	/**	 * MDJBuilder : Multi MD2 in 1 file as MDJ (JSON format)	 * @author katopz	 */	public class MDJBuilder extends MD2Builder	{		public var isIncludeMaterial:Boolean = true;				public var meshPath:String = "";		public var texturePath:String = "";				private var _meshSources:Array/*Mesh Source*/;		private var _textureSources:Array/*Texture Source*/;				private var _animationDatas:Vector.<AnimationData>;				private var _frames:Array;				public function MDJBuilder()		{			super();		}		public function getMDJ(meshes:Vector.<MovieMesh>, optional:Object = null):String		{			// TODO: merge meshPath, texturePath ?			var _mdj:String = JSON.encode(getJSON(meshes, optional));						Debug.trace(" ! MDJ : " + _mdj);						return _mdj;		}				public function getJSON(meshes:Vector.<MovieMesh>, optional:Object = null):Object		{			var _mesh:MovieMesh;			var _materials:Dictionary = new Dictionary(true);			var _url:String;						_meshSources = [];			_textureSources = [];			// write all material as png, TODO : as jpg option 			for each (var _materialData:MaterialData in _materialLibrary)				if (_materialData.textureBitmap)				{					if(_materialData.textureFileName && _materialData.textureFileName != "")						_url = _materialData.textureFileName;					else						_url = _materialData.name + ".png";										_materials[_url] = _materialData.textureBitmap;										Debug.trace(" + Material :" + _url);				}						// md2			for each (_mesh in meshes)			{				if (_mesh.material is BitmapMaterial)				{					for (_url in _materials)						if(_materials[_url] == BitmapMaterial(_mesh.material).bitmapData)							BitmapMaterial(_mesh.material).url = _url;				}								// TODO : save from mesh name as optional?				if(_mesh.url)					_meshSources.push(meshPath + _mesh.url);				else					_meshSources.push(meshPath + _mesh.name + ".md2");								_textureSources.push(texturePath + BitmapMaterial(_mesh.material).url);								Debug.trace(" + Mesh :" + _mesh.name + ".md2");			}						var _json:Object = {frames:_frames, meshes:_meshSources, textures:_textureSources};						// extra optional?			if(optional)			{				for(var i:* in optional)					_json[i] = optional[i];			}						return _json;		}				override public function convert(object3D:Object3D, animationDatas:Vector.<AnimationData> = null, fps:Number = 30, animationName:String = "default"):Vector.<MovieMesh>		{			_frames = [];						// write frame name to JSON			if(animationDatas && animationDatas.length)			{				// loop all animationdatas				for each (var _animationData:AnimationData in animationDatas)				{					Debug.trace(" + Frame [" + _animationData.name + "] : " + _animationData.start + " -> " + _animationData.end);										_frames.push({						name : _animationData.name,						start : _animationData.start,						end : _animationData.end					});				}			}						return super.convert(object3D, animationDatas, fps, animationName);		}	}}